{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prismatopia \u00b6 Prismatopia is a GraphQL API stack combining a bunch of super-awesome technologies: Apollo Server 2, Prisma, Postgres, Docker, AWS, OAuth, Make, Yeoman and more! The Stack \u00b6 Apollo Server 2 Provides a GraphQL server for resolvers, which is where your business logic lives Prisma Provides an ORM to translate from Graphql to Postgres, Apollo resolvers mainly call a Prisma Client to access data Postgres Provides persistent storage for data, this is managed by AWS RDS in production but is run in a container during local development AWS Handles networking (ALB, VPC, etc.) and container management (ECS) OAuth Apollo is setup for validating JWTs from clients (Works with Okta out of the box) Docker There's a local Docker Compose setup for easy development. Also, all AWS services (except Postgres) run in containers The Quickstart \u00b6 Install some tools Yeoman Docker AWS CLI v2+ Install the Yeoman generator for Prismatopia yarn global add generator-prismatopia Create your new project yo prismatopia Start Prismatopia locally make local-up Deploy the data model make local-prisma-deploy Get a token for your local Prisma make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } Run some queries! The Makefile \u00b6 The Makefile in the root directly is intended to provide all of the controls that you'll need for both local development and AWS operations. The Makefile is the Prismatopia CLI. Most targets are specific to a layer (Apollo, Prisma) in a location (local, AWS). Here are a few generally useful targets: make init This command will do some cleanup and will try to ensure that all required packages are in place. It's a good command to start with. make docker-clean This command will do some cleanup of your Docker environment, which can get messy and cluttered at times. make local-up This is a big one! It will use Docker Compose to bring up a local environment with a running Apollo Server, Prisma Server and Postgres Server. Just the FAQ \u00b6 Why Apollo? Why not just let clients talk to Prisma directly? Because Prisma has no mechanism for executing your business logic. It exposes every possible CRUD operation to your entire data model without any controls. Apollo allows us to create resolvers so we can write business logic to carefully control CRUD against the Prisma layer. In fact, Apollo will only expose a very small subset of the API that Prisma exposes. Why Prisma? Why not just use Apollo to talk to the database? Because Prisma is a GraphQL based abstraction layer between the Apollo world of GraphQL and the database, which is Postgres in this case, but could also be many other data stores. Using Prisma allows us to work with a single data model from the frontend client to the backend business logic. This makes the whole system very flexible and fast to work with... at least that's what the brochure claims.","title":"Overview"},{"location":"#prismatopia","text":"Prismatopia is a GraphQL API stack combining a bunch of super-awesome technologies: Apollo Server 2, Prisma, Postgres, Docker, AWS, OAuth, Make, Yeoman and more!","title":"Prismatopia"},{"location":"#the-stack","text":"Apollo Server 2 Provides a GraphQL server for resolvers, which is where your business logic lives Prisma Provides an ORM to translate from Graphql to Postgres, Apollo resolvers mainly call a Prisma Client to access data Postgres Provides persistent storage for data, this is managed by AWS RDS in production but is run in a container during local development AWS Handles networking (ALB, VPC, etc.) and container management (ECS) OAuth Apollo is setup for validating JWTs from clients (Works with Okta out of the box) Docker There's a local Docker Compose setup for easy development. Also, all AWS services (except Postgres) run in containers","title":"The Stack"},{"location":"#the-quickstart","text":"Install some tools Yeoman Docker AWS CLI v2+ Install the Yeoman generator for Prismatopia yarn global add generator-prismatopia Create your new project yo prismatopia Start Prismatopia locally make local-up Deploy the data model make local-prisma-deploy Get a token for your local Prisma make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } Run some queries!","title":"The Quickstart"},{"location":"#the-makefile","text":"The Makefile in the root directly is intended to provide all of the controls that you'll need for both local development and AWS operations. The Makefile is the Prismatopia CLI. Most targets are specific to a layer (Apollo, Prisma) in a location (local, AWS). Here are a few generally useful targets: make init This command will do some cleanup and will try to ensure that all required packages are in place. It's a good command to start with. make docker-clean This command will do some cleanup of your Docker environment, which can get messy and cluttered at times. make local-up This is a big one! It will use Docker Compose to bring up a local environment with a running Apollo Server, Prisma Server and Postgres Server.","title":"The Makefile"},{"location":"#just-the-faq","text":"Why Apollo? Why not just let clients talk to Prisma directly? Because Prisma has no mechanism for executing your business logic. It exposes every possible CRUD operation to your entire data model without any controls. Apollo allows us to create resolvers so we can write business logic to carefully control CRUD against the Prisma layer. In fact, Apollo will only expose a very small subset of the API that Prisma exposes. Why Prisma? Why not just use Apollo to talk to the database? Because Prisma is a GraphQL based abstraction layer between the Apollo world of GraphQL and the database, which is Postgres in this case, but could also be many other data stores. Using Prisma allows us to work with a single data model from the frontend client to the backend business logic. This makes the whole system very flexible and fast to work with... at least that's what the brochure claims.","title":"Just the FAQ"},{"location":"about/","text":"About Prismatopia \u00b6 License \u00b6 MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"About"},{"location":"about/#about-prismatopia","text":"","title":"About Prismatopia"},{"location":"about/#license","text":"MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"apollo/","text":"The Apollo Layer \u00b6 Once you have your Prisma datamodel setup, you'll need to start working on Apollo. Remember, your clients will only ever connect to Apollo, never to Prisma. Prisma is far too wide-open to expose to external clients (web apps, mobile apps, etc). Setting up Okta \u00b6 Apollo has built-in support for authentication using an OIDC compliant identity provider. This example will focus on using Okta, but Auth0 has also been proven to work. Create a new Okta developer account at https://developer.okta.com Note your Okta domain, it will be something like: https://dev-123456-admin.okta.com/ Set the values for the following environment variables in your .env file: APOLLO_TOKEN_ENDPOINT=https://<your okta domain>/oauth2/default/v1/token APOLLO_JWKS_URI=https://<your okta domain>/oauth2/default/v1/keys APOLLO_JWT_ISSUER=https://<your okta domain>/oauth2/default Add a new Native application Enable Authorization Code and Resource Owner Password grant types Set the following environment variabels in your .env file: APOLLO_CLIENT_ID=<The Client ID for your application> APOLLO_CLIENT_SECRET=<The Client Secret for your application> Create a test user and save the username and password in your .env file: APOLLO_TEST_USERNAME APOLLO_TEST_PASSWORD At this point your should be able to successfully run make apollo-token You can use this token in the Apollo playground: http://localhost:8000 Cherry picking from the Prisma API \u00b6 Your Apollo API (the one your clients will talk to) will end up being be a small subset of your Prisma API. You'll only expose the parts of the Prisma API that your clients need and will leave the rest hidden to the world. This will keep your Apollo API development (and testing) to a minimum. Get Prismatopia running: make local-up Run make prisma-generate and review the generated GraphQL schema: apollo/schema/generated/prisma.graphql . Identify a Prisma API call you want to expose to the world. We'll choose Query.users for this example. Edit apollo/schema/apollo.graphql and import only that query: # import Query.users from \"generated/prisma.graphql\" As soon as you save the Apollo schema, nodemon will detect the change and will restart Apollo. Nice, right? Now, you need to create a resolver for this type, which you'll do by creating a resolver function in apollo/src/resolvers/Query.js const users = ( _parent , args , context ) => { // Pass this call directly through to Prisma and return the result return context . prisma . users ( args ) } Note, this is but a simple example. While you may end up just passing many API calls straight through to Prisma, there will also be many times where your Apollo resolvers will contain business logic for data validation, authorization, etc. At this point, you can continue to iterate between cherry picking Prisma API types and implementing resolvers. The key to this process is that there is a single shared datamodel between Apollo and Prisma, which makes using the Prisma client seamless. You should never redefine types that are already defined in Prisma, though you may want to extend them or create new types if your Apollo resovers talk to APIs other than Prisma. Apollo Make Targets \u00b6 make apollo-build Builds the Apollo Docker image make apollo-push Builds and pushes the Apollo Docker image to the Docker repository specified by APOLLO_CONTAINER_IMAGE make apollo-token Generates a JWT for authenticating to Apollo. Very handy for testing!","title":"Apollo Layer"},{"location":"apollo/#the-apollo-layer","text":"Once you have your Prisma datamodel setup, you'll need to start working on Apollo. Remember, your clients will only ever connect to Apollo, never to Prisma. Prisma is far too wide-open to expose to external clients (web apps, mobile apps, etc).","title":"The Apollo Layer"},{"location":"apollo/#setting-up-okta","text":"Apollo has built-in support for authentication using an OIDC compliant identity provider. This example will focus on using Okta, but Auth0 has also been proven to work. Create a new Okta developer account at https://developer.okta.com Note your Okta domain, it will be something like: https://dev-123456-admin.okta.com/ Set the values for the following environment variables in your .env file: APOLLO_TOKEN_ENDPOINT=https://<your okta domain>/oauth2/default/v1/token APOLLO_JWKS_URI=https://<your okta domain>/oauth2/default/v1/keys APOLLO_JWT_ISSUER=https://<your okta domain>/oauth2/default Add a new Native application Enable Authorization Code and Resource Owner Password grant types Set the following environment variabels in your .env file: APOLLO_CLIENT_ID=<The Client ID for your application> APOLLO_CLIENT_SECRET=<The Client Secret for your application> Create a test user and save the username and password in your .env file: APOLLO_TEST_USERNAME APOLLO_TEST_PASSWORD At this point your should be able to successfully run make apollo-token You can use this token in the Apollo playground: http://localhost:8000","title":"Setting up Okta"},{"location":"apollo/#cherry-picking-from-the-prisma-api","text":"Your Apollo API (the one your clients will talk to) will end up being be a small subset of your Prisma API. You'll only expose the parts of the Prisma API that your clients need and will leave the rest hidden to the world. This will keep your Apollo API development (and testing) to a minimum. Get Prismatopia running: make local-up Run make prisma-generate and review the generated GraphQL schema: apollo/schema/generated/prisma.graphql . Identify a Prisma API call you want to expose to the world. We'll choose Query.users for this example. Edit apollo/schema/apollo.graphql and import only that query: # import Query.users from \"generated/prisma.graphql\" As soon as you save the Apollo schema, nodemon will detect the change and will restart Apollo. Nice, right? Now, you need to create a resolver for this type, which you'll do by creating a resolver function in apollo/src/resolvers/Query.js const users = ( _parent , args , context ) => { // Pass this call directly through to Prisma and return the result return context . prisma . users ( args ) } Note, this is but a simple example. While you may end up just passing many API calls straight through to Prisma, there will also be many times where your Apollo resolvers will contain business logic for data validation, authorization, etc. At this point, you can continue to iterate between cherry picking Prisma API types and implementing resolvers. The key to this process is that there is a single shared datamodel between Apollo and Prisma, which makes using the Prisma client seamless. You should never redefine types that are already defined in Prisma, though you may want to extend them or create new types if your Apollo resovers talk to APIs other than Prisma.","title":"Cherry picking from the Prisma API"},{"location":"apollo/#apollo-make-targets","text":"make apollo-build Builds the Apollo Docker image make apollo-push Builds and pushes the Apollo Docker image to the Docker repository specified by APOLLO_CONTAINER_IMAGE make apollo-token Generates a JWT for authenticating to Apollo. Very handy for testing!","title":"Apollo Make Targets"},{"location":"aws/","text":"The AWS Layer \u00b6 \"Code all the things!\" \ud83d\udc48 Deploy to AWS \u00b6 Now the fun part! You have your local Prisma datamodel ready and your Apollo schema and resolvers are working, time to deploy to production! Build the AWS infrastructure \u00b6 Prismatopia uses AWS Cloudformation to build a network and all supporting infrastructure for running your GraphQL backend in AWS. The entire process is scripted using CloudFormation, which makes it repeatable and robust. The scripts are in the aws folder and are divided up in order to minimize bundling too much infrastructure in a single stack. Run make aws-deploy-app to deploy all of the application level infrastructure that's shared between different environments. Run make aws-deploy-env to deploy all of the environment level infrastructure, including the Postgres database, Prisma service and Apollo service. Now, deploy your Prisma datamodel using make aws-prisma-deploy You can now access your services using apollo.<yourdomain> and prisma.<yourdomain> AWS Makefile Targets \u00b6","title":"AWS Layer"},{"location":"aws/#the-aws-layer","text":"\"Code all the things!\" \ud83d\udc48","title":"The AWS Layer"},{"location":"aws/#deploy-to-aws","text":"Now the fun part! You have your local Prisma datamodel ready and your Apollo schema and resolvers are working, time to deploy to production!","title":"Deploy to AWS"},{"location":"aws/#build-the-aws-infrastructure","text":"Prismatopia uses AWS Cloudformation to build a network and all supporting infrastructure for running your GraphQL backend in AWS. The entire process is scripted using CloudFormation, which makes it repeatable and robust. The scripts are in the aws folder and are divided up in order to minimize bundling too much infrastructure in a single stack. Run make aws-deploy-app to deploy all of the application level infrastructure that's shared between different environments. Run make aws-deploy-env to deploy all of the environment level infrastructure, including the Postgres database, Prisma service and Apollo service. Now, deploy your Prisma datamodel using make aws-prisma-deploy You can now access your services using apollo.<yourdomain> and prisma.<yourdomain>","title":"Build the AWS infrastructure"},{"location":"aws/#aws-makefile-targets","text":"","title":"AWS Makefile Targets"},{"location":"prisma/","text":"The Prisma Layer \u00b6 Edit your Prisma data model and seeds: prisma/prisma-datamodel.graphql prisma/seeds.js Deploy your data model changes make local-prisma-deploy Get a Prisma token make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } Prisma Make targets \u00b6 make local-prisma-deploy Deploys data model changes to your local Prisma service. Note: Prisma will need to be running locally for this to work (e.g. \" make local-up \") make local-prisma-deploy-force Prisma will refuse to deploy changes if it can't figure out how to preserve existing data. In those cases, you can use this target to force Prisma to make the changes... or you can just always use this target because you're using fake data anyway, right? make local-prisma-reseed Clear out any existing data and will rerun seeding to give you a fresh cut of data. make local-prisma-token Generate a token for communicating with your local Prisma API. Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } make prisma-generate Generates a JavaScript client (with types!) and a GraphQL schema that reflects the Prisma API. Files are generated here: /apollo/schema/generated/prisma.graphql /apollo/src/generated/prisma-client","title":"Prisma Layer"},{"location":"prisma/#the-prisma-layer","text":"Edit your Prisma data model and seeds: prisma/prisma-datamodel.graphql prisma/seeds.js Deploy your data model changes make local-prisma-deploy Get a Prisma token make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" }","title":"The Prisma Layer"},{"location":"prisma/#prisma-make-targets","text":"make local-prisma-deploy Deploys data model changes to your local Prisma service. Note: Prisma will need to be running locally for this to work (e.g. \" make local-up \") make local-prisma-deploy-force Prisma will refuse to deploy changes if it can't figure out how to preserve existing data. In those cases, you can use this target to force Prisma to make the changes... or you can just always use this target because you're using fake data anyway, right? make local-prisma-reseed Clear out any existing data and will rerun seeding to give you a fresh cut of data. make local-prisma-token Generate a token for communicating with your local Prisma API. Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } make prisma-generate Generates a JavaScript client (with types!) and a GraphQL schema that reflects the Prisma API. Files are generated here: /apollo/schema/generated/prisma.graphql /apollo/src/generated/prisma-client","title":"Prisma Make targets"}]}