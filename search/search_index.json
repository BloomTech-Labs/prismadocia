{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prismatopia \u00b6 What is Prismatopia? \u00b6 Prismatopia is a GraphQL API stack combining a bunch of super-awesome technologies: Apollo Server 2, Prisma, Postgres, Docker, AWS, OAuth, Make, Yeoman and more! The Stack \u00b6 Here are the technologies in the Prismatopia stack... Apollo Server 2 \u00b6 Provides a GraphQL server for resolvers, which is where your business logic lives Prisma \u00b6 Provides an ORM to translate from Graphql to Postgres, Apollo resolvers mainly call a Prisma Client to access data Postgres \u00b6 Provides persistent storage for data, this is managed by AWS RDS in production but is run in a container during local development AWS \u00b6 Handles networking (ALB, VPC, etc.) and container management (ECS) OAuth \u00b6 Apollo is setup for validating JWTs from clients (Works with Okta out of the box) Docker \u00b6 There's a local Docker Compose setup for easy development. Also, all AWS services (except Postgres) run in containers Useful Makefile Targets \u00b6 First, it is very important to note that there is a Makefile in the root directly that is intended to provide all of the controls that you'll need for both local development and AWS operations. make init \u00b6 This command will do some cleanup and will try to ensure that all required packages are in place. It's a good command to start with. make docker-clean \u00b6 This command will do some cleanup of your Docker environment, which can get messy and cluttered at times. make local-up \u00b6 This is a big one! It will use Docker Compose to bring up a local environment with a running Apollo Server, Prisma Server and Postgres Server. FAQ \u00b6 Why Apollo? Why not just let clients talk to Prisma directly? Because Prisma has no mechanism for executing your business logic. It exposes every possible CRUD operation to your entire data model without any controls. Apollo allows us to create resolvers so we can write business logic to carefully control CRUD against the Prisma layer. In fact, Apollo will only expose a very small subset of the API that Prisma exposes. Why Prisma? Why not just use Apollo to talk to the database? Because Prisma is a GraphQL based abstraction layer between the Apollo world of GraphQL and the database, which is Postgres in this case, but could also be many other data stores. Using Prisma allows us to work with a single data model from the frontend client to the backend business logic. This makes the whole system very flexible and fast to work with... at least that's what the brochure claims. MIT \u00a9 Lambda School","title":"Overview"},{"location":"#prismatopia","text":"","title":"Prismatopia"},{"location":"#what-is-prismatopia","text":"Prismatopia is a GraphQL API stack combining a bunch of super-awesome technologies: Apollo Server 2, Prisma, Postgres, Docker, AWS, OAuth, Make, Yeoman and more!","title":"What is Prismatopia?"},{"location":"#the-stack","text":"Here are the technologies in the Prismatopia stack...","title":"The Stack"},{"location":"#apollo-server-2","text":"Provides a GraphQL server for resolvers, which is where your business logic lives","title":"Apollo Server 2"},{"location":"#prisma","text":"Provides an ORM to translate from Graphql to Postgres, Apollo resolvers mainly call a Prisma Client to access data","title":"Prisma"},{"location":"#postgres","text":"Provides persistent storage for data, this is managed by AWS RDS in production but is run in a container during local development","title":"Postgres"},{"location":"#aws","text":"Handles networking (ALB, VPC, etc.) and container management (ECS)","title":"AWS"},{"location":"#oauth","text":"Apollo is setup for validating JWTs from clients (Works with Okta out of the box)","title":"OAuth"},{"location":"#docker","text":"There's a local Docker Compose setup for easy development. Also, all AWS services (except Postgres) run in containers","title":"Docker"},{"location":"#useful-makefile-targets","text":"First, it is very important to note that there is a Makefile in the root directly that is intended to provide all of the controls that you'll need for both local development and AWS operations.","title":"Useful Makefile Targets"},{"location":"#make-init","text":"This command will do some cleanup and will try to ensure that all required packages are in place. It's a good command to start with.","title":"make init"},{"location":"#make-docker-clean","text":"This command will do some cleanup of your Docker environment, which can get messy and cluttered at times.","title":"make docker-clean"},{"location":"#make-local-up","text":"This is a big one! It will use Docker Compose to bring up a local environment with a running Apollo Server, Prisma Server and Postgres Server.","title":"make local-up"},{"location":"#faq","text":"Why Apollo? Why not just let clients talk to Prisma directly? Because Prisma has no mechanism for executing your business logic. It exposes every possible CRUD operation to your entire data model without any controls. Apollo allows us to create resolvers so we can write business logic to carefully control CRUD against the Prisma layer. In fact, Apollo will only expose a very small subset of the API that Prisma exposes. Why Prisma? Why not just use Apollo to talk to the database? Because Prisma is a GraphQL based abstraction layer between the Apollo world of GraphQL and the database, which is Postgres in this case, but could also be many other data stores. Using Prisma allows us to work with a single data model from the frontend client to the backend business logic. This makes the whole system very flexible and fast to work with... at least that's what the brochure claims. MIT \u00a9 Lambda School","title":"FAQ"},{"location":"apollo/","text":"The Apollo Layer \u00b6 Once you have your Prisma datamodel setup, you'll need to start working on Apollo. Remember, your clients will only ever connect to Apollo, never to Prisma. Prisma is far too wide-open to expose to external clients (web apps, mobile apps, etc). Setting up Okta \u00b6 Apollo has built-in support for authentication using an OIDC compliant identity provider. This example will focus on using Okta, but Auth0 has also been proven to work. Create a new Okta developer account at https://developer.okta.com Note your Okta domain, it will be something like: https://dev-123456-admin.okta.com/ Set the values for the following environment variables in your .env file: APOLLO_TOKEN_ENDPOINT https://<your okta domain>/oauth2/default/v1/token APOLLO_JWKS_URI https://<your okta domain>/oauth2/default/v1/keys APOLLO_JWT_ISSUER https://<your okta domain>/oauth2/default Add a new Native application Enable Authorization Code and Resource Owner Password grant types Set the following environment variabels in your .env file: APOLLO_CLIENT_ID The Client ID for your application APOLLO_CLIENT_SECRET The Client Secret for your application Create a test user and save the username and password in your .env file: APOLLO_TEST_USERNAME APOLLO_TEST_PASSWORD At this point your should be able to successfully run make apollo-token You can use this token in the Apollo playground: http://localhost:8000 Cherry picking from the Prisma API \u00b6 Your Apollo API (the one your clients will talk to) will end up being be a small subset of your Prisma API. You'll only expose the parts of the Prisma API that your clients need and will leave the rest hidden to the world. This will keep your Apollo API development (and testing) to a minimum. Get Prismatopia running: make local-up Run make prisma-generate and review the generated GraphQL schema: apollo/schema/generated/prisma.graphql . Identify a Prisma API call you want to expose to the world. We'll choose Query.users for this example. Edit apollo/schema/apollo.graphql and import only that query: # import Query.users from \"generated/prisma.graphql\" As soon as you save the Apollo schema, nodemon will detect the change and will restart Apollo. Nice, right? Now, you need to create a resolver for this type, which you'll do by creating a resolver function in apollo/src/resolvers/Query.js const users = ( _parent , args , context ) => { // Pass this call directly through to Prisma and return the result return context . prisma . users ( args ) } Note, this is but a simple example. While you may end up just passing many API calls straight through to Prisma, there will also be many times where your Apollo resolvers will contain business logic for data validation, authorization, etc. At this point, you can continue to iterate between cherry picking Prisma API types and implementing resolvers. The key to this process is that there is a single shared datamodel between Apollo and Prisma, which makes using the Prisma client seamless. You should never redefine types that are already defined in Prisma, though you may want to extend them or create new types if your Apollo resovers talk to APIs other than Prisma. Local Apollo Make Targets \u00b6 make apollo-build \u00b6 Builds the Apollo Docker image make apollo-push \u00b6 Builds and pushes the Apollo Docker image to the Docker repository specified by APOLLO_CONTAINER_IMAGE make apollo-token \u00b6 Generates a JWT for authenticating to Apollo. Very handy for testing!","title":"Apollo Layer"},{"location":"apollo/#the-apollo-layer","text":"Once you have your Prisma datamodel setup, you'll need to start working on Apollo. Remember, your clients will only ever connect to Apollo, never to Prisma. Prisma is far too wide-open to expose to external clients (web apps, mobile apps, etc).","title":"The Apollo Layer"},{"location":"apollo/#setting-up-okta","text":"Apollo has built-in support for authentication using an OIDC compliant identity provider. This example will focus on using Okta, but Auth0 has also been proven to work. Create a new Okta developer account at https://developer.okta.com Note your Okta domain, it will be something like: https://dev-123456-admin.okta.com/ Set the values for the following environment variables in your .env file: APOLLO_TOKEN_ENDPOINT https://<your okta domain>/oauth2/default/v1/token APOLLO_JWKS_URI https://<your okta domain>/oauth2/default/v1/keys APOLLO_JWT_ISSUER https://<your okta domain>/oauth2/default Add a new Native application Enable Authorization Code and Resource Owner Password grant types Set the following environment variabels in your .env file: APOLLO_CLIENT_ID The Client ID for your application APOLLO_CLIENT_SECRET The Client Secret for your application Create a test user and save the username and password in your .env file: APOLLO_TEST_USERNAME APOLLO_TEST_PASSWORD At this point your should be able to successfully run make apollo-token You can use this token in the Apollo playground: http://localhost:8000","title":"Setting up Okta"},{"location":"apollo/#cherry-picking-from-the-prisma-api","text":"Your Apollo API (the one your clients will talk to) will end up being be a small subset of your Prisma API. You'll only expose the parts of the Prisma API that your clients need and will leave the rest hidden to the world. This will keep your Apollo API development (and testing) to a minimum. Get Prismatopia running: make local-up Run make prisma-generate and review the generated GraphQL schema: apollo/schema/generated/prisma.graphql . Identify a Prisma API call you want to expose to the world. We'll choose Query.users for this example. Edit apollo/schema/apollo.graphql and import only that query: # import Query.users from \"generated/prisma.graphql\" As soon as you save the Apollo schema, nodemon will detect the change and will restart Apollo. Nice, right? Now, you need to create a resolver for this type, which you'll do by creating a resolver function in apollo/src/resolvers/Query.js const users = ( _parent , args , context ) => { // Pass this call directly through to Prisma and return the result return context . prisma . users ( args ) } Note, this is but a simple example. While you may end up just passing many API calls straight through to Prisma, there will also be many times where your Apollo resolvers will contain business logic for data validation, authorization, etc. At this point, you can continue to iterate between cherry picking Prisma API types and implementing resolvers. The key to this process is that there is a single shared datamodel between Apollo and Prisma, which makes using the Prisma client seamless. You should never redefine types that are already defined in Prisma, though you may want to extend them or create new types if your Apollo resovers talk to APIs other than Prisma.","title":"Cherry picking from the Prisma API"},{"location":"apollo/#local-apollo-make-targets","text":"","title":"Local Apollo Make Targets"},{"location":"apollo/#make-apollo-build","text":"Builds the Apollo Docker image","title":"make apollo-build"},{"location":"apollo/#make-apollo-push","text":"Builds and pushes the Apollo Docker image to the Docker repository specified by APOLLO_CONTAINER_IMAGE","title":"make apollo-push"},{"location":"apollo/#make-apollo-token","text":"Generates a JWT for authenticating to Apollo. Very handy for testing!","title":"make apollo-token"},{"location":"aws/","text":"The AWS Layer \u00b6 \"Code all the things!\" \ud83d\udc48 Deploy to AWS \u00b6 Now the fun part! You have your local Prisma datamodel ready and your Apollo schema and resolvers are working, time to deploy to production! Build the AWS infrastructure \u00b6 Prismatopia uses AWS Cloudformation to build a network and all supporting infrastructure for running your GraphQL backend in AWS. The entire process is scripted using CloudFormation, which makes it repeatable and robust. The scripts are in the aws folder and are divided up in order to minimize bundling too much infrastructure in a single stack. Run make aws-deploy-app to deploy all of the application level infrastructure that's shared between different environments. Run make aws-deploy-env to deploy all of the environment level infrastructure, including the Postgres database, Prisma service and Apollo service. Now, deploy your Prisma datamodel using make aws-prisma-deploy You can now access your services using apollo.<yourdomain> and prisma.<yourdomain> AWS Makefile Targets \u00b6","title":"AWS Layer"},{"location":"aws/#the-aws-layer","text":"\"Code all the things!\" \ud83d\udc48","title":"The AWS Layer"},{"location":"aws/#deploy-to-aws","text":"Now the fun part! You have your local Prisma datamodel ready and your Apollo schema and resolvers are working, time to deploy to production!","title":"Deploy to AWS"},{"location":"aws/#build-the-aws-infrastructure","text":"Prismatopia uses AWS Cloudformation to build a network and all supporting infrastructure for running your GraphQL backend in AWS. The entire process is scripted using CloudFormation, which makes it repeatable and robust. The scripts are in the aws folder and are divided up in order to minimize bundling too much infrastructure in a single stack. Run make aws-deploy-app to deploy all of the application level infrastructure that's shared between different environments. Run make aws-deploy-env to deploy all of the environment level infrastructure, including the Postgres database, Prisma service and Apollo service. Now, deploy your Prisma datamodel using make aws-prisma-deploy You can now access your services using apollo.<yourdomain> and prisma.<yourdomain>","title":"Build the AWS infrastructure"},{"location":"aws/#aws-makefile-targets","text":"","title":"AWS Makefile Targets"},{"location":"prisma/","text":"The Prisma Layer \u00b6 Quickstart \u00b6 Install some tools Yeoman Docker AWS CLI v2+ Install the Yeoman generator for Prismatopia yarn global add generator-prismatopia Create your new project yo prismatopia Start Prismatopia locally make local-up Deploy the data model make local-prisma-deploy Get a token for your local Prisma make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } Run some queries! Prisma Development \u00b6 Edit your Prisma data model and seeds: prisma/prisma-datamodel.graphql prisma/seeds.js Deploy your data model changes make local-prisma-deploy Get a Prisma token make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } Local Prisma Make targets \u00b6 make local-prisma-deploy \u00b6 Deploys data model changes to your local Prisma service. Tip Prisma will need to be running locally for this to work (e.g. \" make local-up \") make local-prisma-deploy-force \u00b6 Prisma will refuse to deploy changes if it can't figure out how to preserve existing data. In those cases, you can use this target to force Prisma to make the changes... or you can just always use this target because you're using fake data anyway, right? make local-prisma-reseed \u00b6 Clear out any existing data and will rerun seeding to give you a fresh cut of data. make local-prisma-token \u00b6 Generate a token for communicating with your local Prisma API. Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } make prisma-generate \u00b6 Generates a JavaScript client (with types!) and a GraphQL schema that reflects the Prisma API. Files are generated here: /apollo/schema/generated/prisma.graphql /apollo/src/generated/prisma-client","title":"Prisma Layer"},{"location":"prisma/#the-prisma-layer","text":"","title":"The Prisma Layer"},{"location":"prisma/#quickstart","text":"Install some tools Yeoman Docker AWS CLI v2+ Install the Yeoman generator for Prismatopia yarn global add generator-prismatopia Create your new project yo prismatopia Start Prismatopia locally make local-up Deploy the data model make local-prisma-deploy Get a token for your local Prisma make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" } Run some queries!","title":"Quickstart"},{"location":"prisma/#prisma-development","text":"Edit your Prisma data model and seeds: prisma/prisma-datamodel.graphql prisma/seeds.js Deploy your data model changes make local-prisma-deploy Get a Prisma token make local-prisma-token Open the Prisma playground http://localhost:7000 Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" }","title":"Prisma Development"},{"location":"prisma/#local-prisma-make-targets","text":"","title":"Local Prisma Make targets"},{"location":"prisma/#make-local-prisma-deploy","text":"Deploys data model changes to your local Prisma service. Tip Prisma will need to be running locally for this to work (e.g. \" make local-up \")","title":"make local-prisma-deploy"},{"location":"prisma/#make-local-prisma-deploy-force","text":"Prisma will refuse to deploy changes if it can't figure out how to preserve existing data. In those cases, you can use this target to force Prisma to make the changes... or you can just always use this target because you're using fake data anyway, right?","title":"make local-prisma-deploy-force"},{"location":"prisma/#make-local-prisma-reseed","text":"Clear out any existing data and will rerun seeding to give you a fresh cut of data.","title":"make local-prisma-reseed"},{"location":"prisma/#make-local-prisma-token","text":"Generate a token for communicating with your local Prisma API. Open the 'HTTP Headers' setting in the GraphQL Platground and set your token, like this: { \"Authorization\" : \"Bearer <The token from 'make local-prisma-token'>\" }","title":"make local-prisma-token"},{"location":"prisma/#make-prisma-generate","text":"Generates a JavaScript client (with types!) and a GraphQL schema that reflects the Prisma API. Files are generated here: /apollo/schema/generated/prisma.graphql /apollo/src/generated/prisma-client","title":"make prisma-generate"}]}